"use strict";(self.webpackChunkcmcs_docs=self.webpackChunkcmcs_docs||[]).push([[497],{459:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"prompting_basics","metadata":{"permalink":"/cmcs-docs/blog/prompting_basics","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-04-20-prompting_basics.md","source":"@site/blog/2023-04-20-prompting_basics.md","title":"Prompting Basics","description":"To understand the different types of prompting methods, it is important to first understand the basics of prompting notation. The following table summarizes the different components of prompting notation:","date":"2023-04-20T00:00:00.000Z","formattedDate":"April 20, 2023","tags":[{"label":"Prompting","permalink":"/cmcs-docs/blog/tags/prompting"}],"readingTime":1.805,"hasTruncateMarker":true,"authors":[{"name":"Pasindu Udawatta","title":"Lingua maintainer","url":"https://github.com/PasinduUd","imageURL":"https://avatars.githubusercontent.com/u/61894712?v=4","key":"PasinduUd"}],"frontMatter":{"slug":"prompting_basics","title":"Prompting Basics","authors":"PasinduUd","tags":["Prompting"]},"nextItem":{"title":"Understanding Language Model Prompting","permalink":"/cmcs-docs/blog/Understanding_Language_Model_Prompting"}},"content":"To understand the different types of prompting methods, it is important to first understand the basics of prompting notation. The following table summarizes the different components of prompting notation:\\n\\n\x3c!--truncate--\x3e\\n\\n| Name               | Notation       | Example                                            | Description                                                                                                                                |\\n| ------------------ | -------------- | -------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |\\n| Input              | x              | \\"I love this movie.\\"                               | One or multiple texts                                                                                                                      |\\n| Output             | y              | ++ (very positive)                                 | Output label or text                                                                                                                       |\\n| Prompting Function | fprompt(x)     | [X] Overall, it was a [Z] movie.                   | A function that converts the input into a specific form by inserting the input x and adding a slot [Z] where answer z may be filled later. |\\n| Prompt             | x\'             | \\"I love this movie. Overall, it was a [Z] movie.\\"  | A text where [X] is instantiated by input x but answer slot [Z] is not.                                                                    |\\n| Filled Prompt      | ffill(x\', z)   | \\"I love this movie. Overall, it was a bad movie.\\"  | A prompt where slot [Z] is filled with any answer.                                                                                         |\\n| Answered Prompt    | ffill(x\', z\\\\*) | \\"I love this movie. Overall, it was a good movie.\\" | A prompt where slot [Z] is filled with a true answer.                                                                                      |\\n| Answer             | z              | \\"good\\", \\"fantastic\\", \\"boring\\"                      | A token, phrase, or sentence that fills [Z].                                                                                               |\\n\\nIn this table, `x` represents the input text, which can be one or multiple texts. `y` represents the output label or text that the prompting method is trying to generate. The prompting function `fprompt(x)` is a function that takes in input `x` and returns a prompt `x\'` with a slot `[Z]` for an answer. The filled prompt `ffill(x\', z)` is a prompt where the slot `[Z]` is filled with any answer `z`. The answered prompt `ffill(x\', z*)` is a prompt where the slot `[Z]` is filled with a true answer `z*`. The answer `z` is a token, phrase, or sentence that fills the slot `[Z]`.\\n\\nBy using this notation, we can create different types of prompts for different tasks, such as question answering, summarization, sentiment analysis, and classification, using a single language model."},{"id":"Understanding_Language_Model_Prompting","metadata":{"permalink":"/cmcs-docs/blog/Understanding_Language_Model_Prompting","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-04-19.md","source":"@site/blog/2023-04-19.md","title":"Understanding Language Model Prompting","description":"Language models (LMs) are powerful tools for natural language processing tasks. However, traditional supervised learning approaches require a large amount of labeled data, which is often not available for many tasks. In this context, prompting has emerged as a popular approach for training LMs in low-data scenarios.","date":"2023-04-19T00:00:00.000Z","formattedDate":"April 19, 2023","tags":[{"label":"Language models","permalink":"/cmcs-docs/blog/tags/language-models"},{"label":"Prompting","permalink":"/cmcs-docs/blog/tags/prompting"},{"label":"NLP","permalink":"/cmcs-docs/blog/tags/nlp"}],"readingTime":1.965,"hasTruncateMarker":true,"authors":[{"name":"Indunil Udayangana","title":"Lingua maintainer","url":"https://github.com/indunil-19","imageURL":"https://avatars.githubusercontent.com/u/63807666?v=4","key":"indunil-19"}],"frontMatter":{"slug":"Understanding_Language_Model_Prompting","title":"Understanding Language Model Prompting","authors":["indunil-19"],"tags":["Language models","Prompting","NLP"]},"prevItem":{"title":"Prompting Basics","permalink":"/cmcs-docs/blog/prompting_basics"},"nextItem":{"title":"Prompt Engineering","permalink":"/cmcs-docs/blog/Prompt_Engineering"}},"content":"<p align=\\"center\\">\\n  <img src=\\"https://img.shields.io/badge/Language%20Model-Prompting-blueviolet\\"/>\\n</p>\\n\\nLanguage models (LMs) are powerful tools for natural language processing tasks. However, traditional supervised learning approaches require a large amount of labeled data, which is often not available for many tasks. In this context, prompting has emerged as a popular approach for training LMs in low-data scenarios.\\n\\n\x3c!--truncate--\x3e\\n\\n## Types of Prompting\\n\\n### \ud83d\udfe3 Tuning-free Prompting\\n\\nTuning-free prompting is an efficient approach that doesn\'t require any parameter update process. The LM parameters remain fixed, eliminating the problem of catastrophic forgetting. It\'s also applicable in zero-shot settings, making it an attractive option for some applications. However, it requires heavy engineering to achieve high accuracy, particularly in the in-context learning setting. Additionally, it\'s challenging to use large training datasets because providing many answered prompts can be slow at test time.\\n\\n### \ud83d\udfe2 Fixed-LM Prompt Tuning\\n\\nFixed-LM prompt tuning is similar to tuning-free prompting but can be used in few-shot scenarios to achieve superior accuracy. It\'s not applicable in zero-shot scenarios, and the representation power is limited in large-data settings. Prompt engineering through the choice of hyperparameters or seed prompts is necessary. Prompts are usually not human-interpretable or manipulable (soft prompts).\\n\\n### \ud83d\udfe1 Fixed-prompt LM Tuning\\n\\nIn fixed-prompt LM tuning, prompt or answer engineering more completely specifies the task, allowing for more efficient learning, particularly in few-shot scenarios. However, prompt or answer engineering is still required, although perhaps not as much as without prompting. LMs fine-tuned on one downstream task may not be effective on another one.\\n\\n### \ud83d\udd35 Prompt+LM Tuning\\n\\nPrompt+LM tuning is the most expressive method and likely suitable for high-data settings. It\'s very similar to the standard pre-train and fine-tune paradigm, but the addition of the prompt can provide additional bootstrapping at the start of model training. However, it requires training and storing all parameters of the models and may overfit to small datasets.\\n\\n## Applications of Prompting\\n\\nIn prompting, the language models can be used for different tasks such as question answering, summarization, knowledge probing, sentiment analysis, and classification using a single LM model. However, if we fine-tune LM, we can only use it for the target task in which LM was tuned.\\n\\nPrompting has opened up many possibilities for low-data NLP tasks. With a better understanding of the different types of prompting, researchers and practitioners can choose the most suitable approach for their specific use cases."},{"id":"Prompt_Engineering","metadata":{"permalink":"/cmcs-docs/blog/Prompt_Engineering","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-04-18.md","source":"@site/blog/2023-04-18.md","title":"Prompt Engineering","description":"The recent advances in language models have led to remarkable improvements in various NLP tasks, such as text generation, summarization, question answering, and sentiment analysis. However, even state-of-the-art language models like GPT-3 require massive amounts of training data and compute resources to achieve their impressive performance. In this context, prompt engineering is a promising approach that can significantly improve the efficiency and effectiveness of language models for specific tasks.","date":"2023-04-18T00:00:00.000Z","formattedDate":"April 18, 2023","tags":[{"label":"PromptEngineering","permalink":"/cmcs-docs/blog/tags/prompt-engineering"}],"readingTime":1.66,"hasTruncateMarker":true,"authors":[{"name":"Chathulanka Gamage","title":"Lingua maintainer","url":"https://github.com/cmgchess","imageURL":"https://avatars.githubusercontent.com/u/61736812?v=4","key":"cmgchess"}],"frontMatter":{"slug":"Prompt_Engineering","title":"Prompt Engineering","authors":"cmgchess","tags":["PromptEngineering"]},"prevItem":{"title":"Understanding Language Model Prompting","permalink":"/cmcs-docs/blog/Understanding_Language_Model_Prompting"}},"content":"The recent advances in language models have led to remarkable improvements in various NLP tasks, such as text generation, summarization, question answering, and sentiment analysis. However, even state-of-the-art language models like GPT-3 require massive amounts of training data and compute resources to achieve their impressive performance. In this context, prompt engineering is a promising approach that can significantly improve the efficiency and effectiveness of language models for specific tasks.\\n\\n\x3c!--truncate--\x3e\\n\\nPrompt engineering involves designing effective prompts that can guide the language model to produce the desired output for a given task. There are two main types of prompts: prefix prompts and cloze prompts. Prefix prompts involve adding task-specific vectors to the input text and updating only the prefix during training. This approach has been used in various text generation and text classification tasks. Cloze prompts involve converting subject-relation-object triples or question-answer pairs into a cloze statement that can be used to query the language model.\\n\\nDesigning the best prompt for each task can be done manually or automatically. Manual template designing has been used in many studies, but it has some limitations, as inappropriate prompts can lead to lower performance or incomplete knowledge contained in the language model. Automated template designing can be done using discrete or continuous prompts. Discrete prompts involve defining a set of trigger tokens that can be learned using gradient-based search strategies. Continuous prompts involve optimizing continuous vectors that are prepended to the input text. This approach, called pre-fix tuning, has been used in various studies to optimize language models for specific tasks while keeping the pre-trained parameters frozen.\\n\\nTo sum up, prompt engineering is a promising approach to improve the performance of language models for specific tasks. Effective prompts can significantly reduce the training data and compute resources required to achieve state-of-the-art performance, while also enhancing the interpretability and transparency of language models. Further research is needed to explore the optimal prompt engineering methods for various NLP tasks and to develop automated methods for prompt template designing."}]}')}}]);